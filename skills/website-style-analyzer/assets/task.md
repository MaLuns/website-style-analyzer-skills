# Objective

Analyze the visual and component style system of `{{TARGET_URL}}` (target host: `{{TARGET_HOST}}`), and produce a reusable style guide for downstream AI coding so generated pages stay consistent, maintainable, and scalable.

## Scope and Constraints

- Site scope:
  - Primary domain: `{{TARGET_HOST}}`
  - Include official subdomains: `{{INCLUDE_SUBDOMAINS}}`
  - Exclude third-party outbound pages and private authenticated back-office pages (when access is unavailable)
- Analysis limit: analyze at most `{{MAX_PAGES}}` page links
- Page priority:
  1. Homepage and pages reachable from main navigation
  2. Core conversion pages (Pricing, Docs entry, CTA landing pages, etc.)
  3. Other high-frequency template pages (list/detail/form, etc.)
- Deduplication rules:
  - Never re-analyze URLs already completed; sample only 1-2 representative pages per template type
  - Canonicalize URL before dedupe: remove `utm_*` and tracking params, remove hash, normalize trailing slash, protocol, and casing
- Analysis environment baseline:
  - Browser: Chrome (same major version)
  - Viewports: Desktop `1440x900`, Mobile `390x844`
  - Theme: `{{THEME}}`

## Preflight Capability Checks

Before formal analysis, complete all checks below:

1. Browser MCP is available (open page, snapshot, style inspection).
2. Target site `{{TARGET_URL}}` is reachable.
3. Output directory is writable (`{{OUTPUT_DIR}}`).

If any check fails, stop immediately, record failed checks and reasons, and continue only after capabilities are restored.

## Analysis Workflow

1. Page collection  
   Extract internal links from the seed page (homepage), enqueue by priority, and record `URL`, `page type`, `priority`, and `status`.
2. Global style extraction (Draft)  
   Extract global visual tokens (color, typography, type scale, spacing, radius, shadow, border, breakpoints, motion basics). Keep them as `draft` during analysis.
3. Component detection and classification (baseline + extension)  
   Baseline components for coverage checks (not a closed set):
   - P0: Button, Form Controls (Input/Select/Checkbox/Radio), Card, Navbar/Footer, Modal/Drawer, Table/Pagination.
   - P1: Link, Tabs, Tooltip/Badge/Tag.
   Also detect high-value custom components and add `components/{new-component}.md` using `component.md` template guidance.
4. Component style and interaction analysis (cross-page sampling)  
   Sample different states of the same component across pages and consolidate cross-page conclusions.  
   Record structure, visuals, state matrix by applicability, motion, accessibility, and responsive rules.
5. Page closure and queue progression  
   Consolidate findings for the current page, mark page status as `done`, extract new links, and dedupe. Stop when any condition is met:
   - `{{MAX_PAGES}}` pages completed.
   - When `MAX_PAGES >= 15`: at least 15 high-value pages covered and no new templates found in 5 consecutive new pages after template coverage is reached.
6. Final consolidation  
   After stop conditions are met, finalize component-level conclusions first, then promote global tokens from `draft` to `final`, and sync `brand-tokens.md` and `tokens.json`.

## Output Specification

Expected outputs generated by the analysis process. Template files in `assets` are references only and must not be copied verbatim to output:

- `brand-tokens.md`
- `tokens.json`
- `page-inventory.md`
- `components/`

### 1) Global Style Document

Output file: `brand-tokens.md`  
Core fields:
- Primary color decision rule: weighted by "brand recognizability + high-frequency usage in CTA/key interactions", not by raw occurrence count alone.
- Each color must include: `hex`, `rgb`, use case, suggested ratio, recommended text color, contrast result.

### 2) Machine-Readable Token File

Output file: `tokens.json`  
Requirements:
- Stable naming, such as `color.primary.500`, `component.button.primary.bg.default`.
- Component tokens must map directly to style properties with no extra interpretation.
- Lifecycle:
  - `draft`: for in-analysis reference.
  - `final`: finalized after cross-page and cross-component consolidation.

### 3) Component Style Documents

Template reference: `assets/component.md` (common component style structure)  
Output directory: `components/` (one file per component)  
Each component file must include at least:
- Usage scenarios and variants, anatomy, token mappings.
- State matrix (interactive components must cover `default/hover/focus/focus-visible/active/disabled`; add `loading` when async/submit state exists; mark non-applicable states as `N/A` with rationale).
- Interaction/motion and responsive rules.
- Minimal reusable implementation snippet with token mapping example.

### 4) Analysis Inventory Document

Output file: `page-inventory.md`  
Fields: `URL`, `canonical URL`, `page type`, `priority`, `analysis status`, `template class`, `analysis date`, `notes`.

## AI Execution Constraints

- Read this file and template guidance under `assets` before starting.
- Update `page-inventory.md` after each analyzed page.
- Keep `tokens.json` as `draft` during analysis; switch to `final` after consolidation.
- Write component results to `components/{component}.md` and follow `assets/component.md`.
- Do not copy template files verbatim to output.
- Baseline components are for coverage checks and do not restrict adding new components.
- Do not fabricate missing components or states to satisfy coverage targets; use `N/A` with rationale.

## Definition of Done (DoD)

- Page coverage:
  - When `MAX_PAGES >= 15`: analyze at least 15 high-value pages, and never exceed `{{MAX_PAGES}}`.
  - When `MAX_PAGES < 15`: analyze at least `{{MAX_PAGES}}` pages.
- Component coverage: within observable site scope, baseline component coverage must be at least 80%; components not present may be marked `N/A` (with rationale) and excluded from denominator.
- P0 completeness: all observed P0 components must be fully covered with state matrix, cross-page conclusions, and token mappings; unobserved ones must be marked `N/A` (with rationale).
- Deployable primary colors: output at least `primary`, `neutral`, and `semantic` groups with clear usage boundaries.
- Reusability: AI coding can directly implement from final tokens and component documents.
